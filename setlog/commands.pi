%% module commands
%
% TBD

module commands.

import util.
import solver.
import global.
import log_h.
import prompt.

go => main.
main =>
    init, introduce, obeyCommands, halt.


%% init() is det

init => 
    log_mode([v,vv,vvv]),
    global(last_command_idx, 0), 
    global(last_commands, new_map()),
    global(last_args, new_map()), true.


%% introduce() is det

introduce =>
    println("This is the pure implementation of {log} in Picat."),
    println("Copyright (C) 2019 Luca Parolari <luca.parolari23@gmail.com>"),
    println("  This program is free software, covered by the !!!TODO!!! GNU General Public License, and you are welcome to change it and/or distribute copies of it under certain conditions."),
    println("  There is ABSOLUTELY NO WARRANTY for this program."),
    println("Type 'copying' to see the conditions"),
    println("Type 'warranty' for details."),
    println("Type 'help' for advice, 'quit' to exit."),
    nl, println("Default settings follows."),
    nl, doCommand(info),
    nl, true.


%% obeyCommands() is det
% 
% @desc Realizes the cycle of interaction with the user:
%  commands are read, their legality is checked and,
%  if they are correct, they are executed.

obeyCommands() ?=>
    while(true)
        [Command | Arguments] = readCommandLine(),
        if membchk(Command, [copying,
                            warranty,
                            help,
                            quit,
                            info,
                            solve, 
                            up, 
                            log]) then
            if Command !== up then
                push_last_command(Command, Arguments)
            end,
            doCommand(Command, Arguments)
        else 
            unknownCommand(Command)
        end
    end.
obeyCommands() => obeyCommands().

%% doCommand(Command) is det

doCommand(Command) => doCommand(Command, _).


%% doCommand(Command, Args) is det
%
% @param Command:atom  is an atom representing a command;
% @param Args:list     is a (possibly empty) list of arguments
%
% @desc Causes the execution of the command Command
%   with arguments Args.

% Quit the system.
doCommand(quit, _) =>
    println("Bye!"),
    abort.

% Show warranty informations.
doCommand(warranty, _) =>  % TBD
    println("Warranty").

% Show copying informations.
doCommand(copying, _) =>  % TBD
    println("Copying").

% Show informations about the system.
doCommand(info, _) =>
    println("Current log level: " ++ log_mode().to_string), 
    println("    Echo enabled : " ++ get_echo_enabled().to_string),
    true.

% Show the help message.
doCommand(help, Args) =>  % TBD
    if Args.len() == 0 then
        println("Setlog provides you with the following commands:"), nl,
        println("help      - the command you have just issued;"),
        println("info      - display the current interpreter status;"),
        println("up   <n>  - redo the last <n> command (leave empty for the last one);"),
        println("log  <m>  - set the log mode to <m> (available log mode: " ++ get_log_modes().to_string ++ ");"),
        println("solve <f> - solve the formula <f> with the solver;") 
    elseif Args.first() == solve then
        println("SYNOPSIS"),
        println("\t{log} => TERM."), nl,
        println("\tTERM ::= COMMAND | FORMULAS"), nl,
        println("\tCOMMAND ::= halt | config | help"), nl,
        println("\tFORMULAS ::= array(FORMULA, FORMULA...)"),
        println("\tFORMULA ::= eq(TERM, TERM) | neq(TERM, TERM) | ..."), nl,
        println("\tNote that array(...) is a handy name for [...]."), nl, 
        println("DESCRIPTION"),
        println("\tA short description")
    end.

% Manage log level. 
doCommand(log, Args) =>  % TBD
    if Args.len() != 1 then wrongArgNumber(log, 1), fail end,
    parse_term(Args.first().to_string(), Term, _Vars),
    if (membchk(Term, get_log_modes())) then
        log_mode(Term)
    else
        wrongArgValues(log, mode, get_log_modes())
    end.

% Run the last issued executed command.
doCommand(up, []) => 
    [Command | Args] = get_last_command(), 
    doCommand(Command, Args).
doCommand(up, _Arguments@[N|_]) => 
    [Command | Args] = get_last_command(N.to_string().to_int()),
    doCommand(Command, Args).

% Run the solver and solves the formula passed in the first argument. 
doCommand(solve, _) =>  % TBD
    print("{log} => "), S = read_line(),
    %writeln(S),
    parse_term(S, Term, Vars),
    top_level(Term, Vars),
    true.

% Run a commands that does nothing.
doCommand(skip, _) => 
    println("No action performed."),
    true.


%% readCommandLine() = CommandArgs is det
%
% @return CommandArgs:list  A list of atoms
%
% @desc Reads a command line (up to the end-of-line character) from the
%  controlling terminal, instantiating L with the list of words
%  (strings of non-blank characters) that have been read.
%
% @example 
%   For example, if the user enters
%     load test/mergesort
%   then, on exit,
%     L = ['load', 'test/mergesort']

readCommandLine() = CommandArgs =>
    print("log> "),
    Line := read_line(),
    Line := lstrip(Line),
    Line := rstrip(Line),
    Words = split(Line),
    CommandArgs = [Word.to_atom() : Word in Words].


%% push_last_command(Command, Args) is det
% 
% @desc Push the command Command with its args Args in the commands history.
%  The commands history follows an index ordering, starting by zero. Thus, the first pushed
%  command has the index 0, and the the counter is incremented.

push_last_command(Command, Args) =>
    I = global(last_command_idx),  CM = global(last_commands),  AM = global(last_args),
    CM.put(I, Command), AM.put(I, Args), I := I + 1,
    global(last_command_idx, I), global(last_commands, CM), global(last_args, AM).


%% get_last_command(N) = CommandArgs:list is det
%
% @desc Retrieve the last N-th - 1 command executed.
% @return A list which head is the last command executed, and the rest its args.

get_last_command()  = CommandArgs => CommandArgs = get_last_command(0).

get_last_command(N) = CommandArgs, N >= 0 =>
    I = global(last_command_idx), CM = global(last_commands), AM = global(last_args),
    I := I - N - 1,
    if CM.has_key(I), AM.has_key(I) then
        CommandArgs = [CM.get(I) | AM.get(I)]
    else
        CommandArgs = [skip | []]
    end.


%% unknownCommand(Command) is det
%
% @param Command:atom The issued command.

unknownCommand(Command) =>
    println("Unknown command '" ++ Command.to_string ++ "': type 'help' for advice or 'quit' to exit").


%% wrongArgNumber(Command, N) is det
%
% @param Command:atom The issued command.
% @param N:int The required number of args.
%
% @desc Display an error message concerning number of args for command Command.

wrongArgNumber(Command, N) =>
    println("Wrong argument number for command '" ++ Command.to_string ++ "'."), 
    if N > 1 then T = "args" else T = "arg" end,
    println("This command requires " ++ N.to_string ++ " " ++ T.to_string ++ ".").


%% wrongArgValues(Command, Arg, Choices) is det
%
% @param Command:atom The issued command.
% @param Arg:atom The arg with wrong values.
% @param Choices:list A (possibly empty) list of choices for parameters.
%
% @desc Display an error message concerning wrong values for arg Arg in command Command, and 
%       shows choices Choices if not empty.

wrongArgValues(Command, Arg, Choices) =>
    println("Wrong argument value for command '" ++ Command.to_string ++ "' with arg '" ++ Arg.to_string ++ "'."), 
    if Choices.len() > 0 then   println("Choose one of: " ++ Choices.to_string ++ ".")   end.