%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%                             The {log} solver
%%
%%
%%                               developed by
%%                    Luca Parolari        Gianfranco Rossi
%%
%%                                 May 2019
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% module solver
%
% @author Luca Parolari <luca.parolari23@gmail.com>
% @version 0.6.0

module solver.

import prompt.
import log_h.
import lset.

top_level(Term, Vars) ?=>
    log_d_v("setlog"),
    log_d_vv("setlog :: Term="++Term.to_string),
    log_d_vv("setlog :: Vars="++Vars.to_string),
    solve(Term, Res),
    println("Result: " ++ Res.to_string),
    if anothersol() == 1 then   fail   end.

top_level(_, _) =>
    println("no!").

anothersol() = A => 
    nl,
    A = confirm("Another solution?").

solve(Formulas, FormulaRes) =>
    log_d_v("solve/2"),
    FormulasNew := [],
    foreach (Formula in Formulas)
        log_d_vvv("solve/2 :: foreach : Formula before="++Formula.to_string),
        sat(Formula, Res),
        log_d_vvv("solve/2 :: foreach : Res="++Res.to_string),
        FormulasNew := FormulasNew ++ Res,
        log_d_vvv("solve/2 :: foreach : FormulasNew="++FormulasNew.to_string)
    end,
    log_d_vvv("solve/2 :: Formulas="++Formulas.to_string),
    log_d_vvv("solve/2 :: FormulasNew="++FormulasNew.to_string),
    println("  " ++ Formulas.to_string ++ "  ==>  " ++ FormulasNew.to_string),
    if FormulasNew !== Formulas then
        log_d_vvv("solve/2 :: FOld not equal FNew"),
        solve(FormulasNew, FormulaRes)
    else
        log_d_vvv("solve/2 :: FOld equal FNew"),
        FormulaRes = FormulasNew
    end.
    

sat(F1, FR), F1 == [] => 
    log_d_vv("sat/2 :: empty"),
    FR = [].
sat(F1, FnewR) =>
    log_d_vv("sat/2 :: formula"),
    log_d_vvv("sat/2 :: F1="++F1.to_string++", FnewR="++FnewR.to_string),
    rule(F1,FnewR).

% ENHANCEMENT: add a rule preprocessor that removes duplicates from $set([ ... ]) 
% -- no more required?
rule(eq(T1,T2), R) => eq(T1, T2, R).
rule(neq(T1, T2), R) => neq(T1, T2, R).
rule(or(T1, T2), R) => or(T1, T2, R).
rule(or(T), R) => or(T, R).
rule(insl(T, X), R) => insl(T, X, R).


% ****** equality constraints

%eq(T1, T2, R) ?=>
%    log_d_vvv("eq :: eq_DEBUG : T1=" ++ T1.to_string ++ ", T2=" ++ T2.to_string),
%    fail.

eq(T1, T2, R), T1 == T2 =>                                         % 1
    log_d_vv("eq :: eq_1"),
    R = [].

eq(T1, T2, R), nonvar(T1), var(T2) =>                              % 2
    log_d_vv("eq :: eq_2"),
    eq(T2, T1, R).

eq(T1, T2, R), var(T1), T2.is_lset(),
               not occur_check(T1, T2.lhead()),  % SOUNDNESS?
               T1 == T2.lrest() =>                                 % 3
    log_d_vv("eq :: eq_3"),
    eq(T1, new_lset(T2.lhead(), _N), R).

eq(T1, T2, _R), occur_check(T1, T2) =>                             % 4
    log_d_vv("eq :: eq_4"),
    fail.  % intentionally fail.

eq(T1, T2, R), var(T1) =>                                          % 5
    log_d_vv("eq :: eq_5"),
    R = [], T1 = T2.

eq(T1, T2, _R), struct(T1), struct(T2), 
                T1.name() !== T2.name() =>                         % 6
    log_d_vv("eq :: eq_6"),
    fail.  % intentionally fail.

eq(T1@lset(X, A), T2@lset(Y, A), R) =>                             % 7a
    log_d_vv("eq :: eq_7a"),

    if T1.lhead().len() == 0 then   true   end,

    XElem = T1.lhead().first(),
    XSlice = slice(T1.lhead(), 2),
    foreachnd_slice(Y, YElem, YSlice),
    
    log_d_vvv("eq:: eq_7 : XElem=" ++ XElem.to_string ++ ", YElem=" ++ YElem.to_string),
    R1 = [$eq(XElem, YElem)],
    log_d_vvv("eq:: eq_7 : XSlice=" ++ YSlice.to_string ++ ", YSlice=" ++ XSlice.to_string),
    R2 = [$eq( $lset(XSlice, A), $lset(YSlice, A))],

    R = R1 ++ R2.

eq(T1@lset(X, A), T2@lset(Y, A), R) =>                             % 7b
    log_d_vv("eq :: eq_7b"),

    if T1.lhead().len() == 0 then   true   end,

    XElem = T1.lhead().first(),
    XSlice = X,  % no slice for X.
    foreachnd_slice(Y, YElem, YSlice),
    
    log_d_vvv("eq:: eq_7 : XElem=" ++ XElem.to_string ++ ", YElem=" ++ YElem.to_string),
    R1 = [$eq(XElem, YElem)],
    log_d_vvv("eq:: eq_7 : XSlice=" ++ YSlice.to_string ++ ", YSlice=" ++ XSlice.to_string),
    R2 = [$eq( $lset(XSlice, A), $lset(YSlice, A))],

    R = R1 ++ R2.

eq(T1@lset(X, A), T2@lset(Y, A), R) =>                             % 7c
    log_d_vv("eq :: eq_7c"),

    if T1.lhead().len() == 0 then   true   end,

    XElem = T1.lhead().first(),
    XSlice = slice(T1.lhead(), 2),
    YSlice = Y,  % no slice for Y.
    foreachnd_slice(Y, YElem, _),
    
    log_d_vvv("eq:: eq_7 : XElem=" ++ XElem.to_string ++ ", YElem=" ++ YElem.to_string),
    R1 = [$eq(XElem, YElem)],
    log_d_vvv("eq:: eq_7 : XSlice=" ++ YSlice.to_string ++ ", YSlice=" ++ XSlice.to_string),
    R2 = [$eq( $lset(XSlice, A), $lset(YSlice, A))],

    R = R1 ++ R2.

eq(T1@lset(X, A), T2@lset(Y, A), R) =>                             % 7d
    log_d_vv("eq :: eq_7d"),

    if T1.lhead().len() == 0 then   true   end,

    XElem = T1.lhead().first(),
    XSlice = slice(T1.lhead(), 2),

    R1 = [$eq( A, lset([XElem],N) )],
    R2 = [$eq( lset(XSlice,N), lset(Y, N) )],

    R = R1 ++ R2.

eq(T1@lset([X|Xs], A), T2@lset([Y|Ys], B), R), 
        T1.is_lset(), T2.is_lset() ?=>                             % 8a
    log_d_vv("eq :: eq_8a"),
    eq(X, Y, R1),
    eq(A, B, R2),
    R = R1 ++ R2.
eq(T1@lset([X|Xs], A), T2@lset([Y|Ys], B), R), 
        T1.is_lset(), T2.is_lset() ?=>                             % 8b
    log_d_vv("eq :: eq_8b"),
    eq(X, Y, R1),
    eq(T1, B, R2),
    R = R1 ++ R2.
eq(T1@lset([X|Xs], A), T2@lset([Y|Ys], B), R), 
        T1.is_lset(), T2.is_lset() ?=>                             % 8c
    log_d_vv("eq :: eq_8c"),
    eq(X, Y, R1),
    eq(A, T2, R2),
    R = R1 ++ R2.
eq(T1@lset([X|Xs], A), T2@lset([Y|Ys], B), R), 
        T1.is_lset(), T2.is_lset() =>                              % 8d
    log_d_vv("eq :: eq_8d"),
    eq(A, $lset([Y], N), R1),
    eq($lset([X], N), B, R2),
    R = R1 ++ R2.

eq(T1, T2, R), struct(T1), struct(T2) =>                           % 9
    log_d_vv("eq :: eq_9"),
    R = [],
    T1.name() == T2.name(),  % redundant check.
    T1.arity() == T2.arity(),
    foreach (I1 in 1..T1.arity())
        X1 := T1[I1], X2 := T2[I1],
        eq(X1, X2, RR),
        R := R ++ RR
    end.


% ****** inequality constraints

neq(T1, T2, _R), T1 == T2 =>                                       % 1
    log_d_vv("neq :: neq_1"),
    fail.  %intentionally fail.

neq(T1, T2, R), nonvar(T1) =>                                      % 2
    log_d_vv("neq :: neq_2"),
    R = [$neq(T2, T1)].

neq(T1, T2@lset(Y, T1), R),
        not occur_check(T1, Y) =>                                  % 3
    log_d_vv("neq :: neq_3"),
    RR = [],
    foreach(YElem in Y)
        RR := RR ++ [$neq(YElem, T1)] 
    end,
    R = [$or(RR)]. % FIXME

neq(T1, T2, R), occur_check(T1, T2) =>                             % 4 
    log_d_vv("neq :: neq_4"),
    R = [].

neq(T1@lset(X,A), T2@lset(Y,B), R),
        X.len() == 1, Y.len() == 1 ?=>                             % 5a
    log_d_vv("neq :: neq_5a"),
    R = [$insl(N, $lset(X,A), R1), $nin(N, $lset(Y, B))].

neq(T1@lset(X,A), T2@lset(Y,B), R),
        X.len() == 1, Y.len() == 1 ?=>                             % 5b
    log_d_vv("neq :: neq_5b"),
    R = [$nin(N, $lset(X,A), R1), $insl(N, $lset(Y, B))].

neq(T1, T2, R), 
        struct(T1), struct(T2), 
        name(T1) !== name(T2) =>                                   % 6a
    log_d_vv("neq :: neq_6a"),
    R = [].

neq(T1, T2, R), 
        struct(T1), struct(T2),
        arity(T1) !== arity(T2) =>                                 % 6b
    log_d_vv("neq :: neq_6b"),
    R = [].

neq(T1, T2, R), 
        struct(T1), struct(T2) =>                                  % 7
    log_d_vv("neq :: neq_7"),
    RR = [],
    foreach (I in 1..T1.arity())
        X1 = T1[I], X2 = T2[I],
        RR := RR ++ [$neq(X1, X2)]
    end,
    R = [$or(RR)].

neq(T1, T2, R) => % temp / DEFAULT??? FIXME
    log_d_vv("neq :: neq_temp"),
    R = [$neq(T1, T2)].


% ****** membership constraints

insl(_T, set([]), R) =>         % 1
    log_d_vv("insl :: in_1"), 
    R = [], 
    false.
insl(T, set([U | UR]), R) =>   % 2
    log_d_vv("insl :: in_2"),
    T1 = $eq(T, U),
    T2 = $insl(T, $set([UR].flatten())),
    or(T1, T2, R).
insl(T, set(A), R) =>          % 3
    log_d_vv("insl :: in_3"), 
    A = [T|_X],  % non Ã¨ un vincolo, giusto? Non serve restituirlo, basta riscrivere A (?)
    R = [].


% ****** goal disjunction

%% or(T1, T2, R) is nondet
%
% Try satisfying a binary disjunction goal.
or(T1, _T2, R) ?=> 
    log_d_vv("or :: first"), 
    sat(T1, R).
or(_T1, T2, R) ?=> 
    log_d_vv("or :: second"),
    sat(T2, R).

%% or(T, R) is nondet
%
% Try satisfying a list of disjunction goals.
or([], []) ?=>
    % nothing to do.
    log_d_vv("or/2 :: first").
or([T|_Tr], R) ?=>
    % try satifying the first element of the list.
    log_d_vv("or/2 :: second"),
    sat(T, R).
or([_T|Tr], R) ?=>
    % try satisfyng the rest of the list.
    log_d_vv("or/2 :: third"),
    or(Tr, R).


% *********************************************************
% aux predicates 

%% occur_check(+X, +Y) is det
% The predicate is true whether the variable X is a member of vars(Y).
% X: the variable to find.
% Y: the lookup term.
occur_check(X, Y) => membchk(X, vars(Y)).

% R is the boolean result used for the function is_occur_check.
occur_check(X, Y, R) ?=> occur_check(X, Y), R = 1.
occur_check(_X, _Y, R) => R = 0.
is_occur_check(X, Y) = R => occur_check(X, Y, R).


foreachnd_slice(List, Elem, Slice) => 
    foreachnd_slice(List, Elem, Slice, 1, List.len()).

foreachnd_slice(List, Elem, Slice, I, Ie), I <= Ie ?=>
    [Elem|_] = slice(List, I, I),
    Slice = slice(List, 1, I-1) ++ slice(List, I+1, Ie).
foreachnd_slice(List, Elem, Slice, I, Ie), I <= Ie ?=>
    foreachnd_slice(List, Elem, Slice, I + 1, Ie).