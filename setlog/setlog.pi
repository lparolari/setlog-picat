%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%                     The {log} interpreter and solver
%%
%%
%%                               developed by
%%                   L uca Parolari        Gianfranco Rossi
%%
%%                                 May 2019
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% module setlog
%
% @author Luca Parolari <luca.parolari23@gmail.com>
% @version 0.5.0

module setlog.

import prompt.
import log_h.
import lset.

% picat setlog.pi
main => setlog.

% setlog entry point.
setlog => 
    setlog([$log_mode([none])]),
    hall.
% setlog entry point with options.
setlog([$log_mode(LogMode)]) =>
    log_mode(LogMode),
    hall.
% setlog entry point with debugger enabled.
setlog_d =>
    setlog([$log_mode([v])]),
    hall.
setlog_dd =>
    setlog([$log_mode([v, vv])]),
    hall.
setlog_ddd =>
    setlog([$log_mode([v, vv, vvv])]),
    hall.

hall => 
    log_d_v("hall"),

    print("{log} => "),
    Term = read_term(),
    nl,

    if     Term == halt      then  println("Bye"), abort
    elseif Term == config    then  println("Configs")     % TBD
    elseif not Term.list()   then  lhelp()    % TBD
    else                           top_level(Term)
    end,
    
    hall.

top_level(Term) ?=>
    log_d_v("setlog"),
    
    log_d_vv("setlog :: Term="++Term.to_string),

    solve(Term, Res),

    nl,
    println("Result: " ++ Res.to_string),

    if anothersol() == 1 then 
        fail
    else
        nl, nl,
        hall()
    end.
    
top_level(_) =>
    println("no!"), nl, nl, 
    hall().

anothersol() = A => 
    nl,
    A = confirm("Another solution?").

lhelp() => 
    println("Welcome to setlog interpreter!"), nl,
    println("SYNOPSIS"),
    println("\t{log} => [COMMAND]"), nl,
    println("\tCOMMAND ::= CMD | FORMULAS"),
    println("\tCMD ::= halt | config | help"),
    println("\tFORMULAS ::= array(FORMULA, FORMULA...)"),
    println("\tFORMULA ::= eq(TERM, TERM) | neq(TERM, TERM)"), nl,
    println("\tNote that array(...) is a handy name for [...]."), nl, 
    println("DESCRIPTION"),
    println("\tA short description").


solve(Formulas, FormulaRes) =>
    log_d_v("solve/2"),
    FormulasNew := [],
    foreach (Formula in Formulas)
        log_d_vvv("solve/2 :: foreach : Formula before="++Formula.to_string),
        sat(Formula, Res),
        log_d_vvv("solve/2 :: foreach : Res="++Res.to_string),
        FormulasNew := FormulasNew ++ Res,
        log_d_vvv("solve/2 :: foreach : FormulasNew="++FormulasNew.to_string)
    end,
    log_d_vvv("solve/2 :: Formulas="++Formulas.to_string),
    log_d_vvv("solve/2 :: FormulasNew="++FormulasNew.to_string),
    println(Formulas.to_string ++ "  ==>  " ++ FormulasNew.to_string),
    if FormulasNew !== Formulas then
        log_d_vvv("solve/2 :: FOld not equal FNew"),
        solve(FormulasNew, FormulaRes)
    else
        log_d_vvv("solve/2 :: FOld equal FNew"),
        FormulaRes = FormulasNew
    end.
    

sat(F1, FR), F1 == [] => 
    log_d_vv("sat/2 :: empty"),
    FR = [].
sat(F1, FnewR) =>
    log_d_vv("sat/2 :: formula"),
    log_d_vvv("sat/2 :: F1="++F1.to_string++", FnewR="++FnewR.to_string),
    rule(F1,FnewR).

% ENHANCEMENT: add a rule preprocessor that removes duplicates from $set([ ... ]) 
% -- no more required?
rule(eq(T1,T2), R) => eq(T1, T2, R).
rule(neq(T1, T2), R) => neq(T1, T2, R).
rule(or(T1, T2), R) => or(T1, T2, R).
rule(or(T), R) => or(T, R).
rule(insl(T, X), R) => insl(T, X, R).


% ****** equality constraints

%eq(T1, T2, R) ?=>
%    log_d_vvv("eq :: eq_DEBUG : T1=" ++ T1.to_string ++ ", T2=" ++ T2.to_string),
%    fail.

eq(T1, T2, R), T1 == T2 =>                                         % 1
    log_d_vv("eq :: eq_1"),
    R = [].

eq(T1, T2, R), nonvar(T1), var(T2) =>                              % 2
    log_d_vv("eq :: eq_2"),
    eq(T2, T1, R).

% non deterministic because can fail in not occur_check or in T1 == T2.lrest()
eq(T1, T2, R), T1.is_lset(), T2.is_lset() ?=>                       % 3
    log_d_vv("eq :: eq_3"),
    not occur_check(T1, T2.lhead()),  % SOUNDNESS?
    T1 == T2.lrest(),
    eq(T1, new_lset(T2.lhead(), _N), R).

eq(T1, T2, _R), occur_check(T1, T2) =>                              % 4
    log_d_vv("eq :: eq_4"),
    fail. % intentionally fail.

eq(T1, T2, R), var(T1) => %, nonvar(T2) => % siamo sicuri del nonvar?? FIXME  % 5
    log_d_vv("eq :: eq_5"),
    R = [], T1 = T2.

eq(T1, T2, _R), struct(T1), struct(T2), T1.name() !== T2.name() =>  % 6
    log_d_vv("eq :: eq_6"),
    fail. % intentionally fail.
    
eq(T1, T2, R), T1.is_lset(), T2.is_lset() =>                        % 7 
    log_d_vv("eq :: eq_7"), 
    T1.lrest() == T2.lrest(),
    R = [],
    if T1.lhead().len() !== 0 then
        X = T1.lhead().first(),
        foreach (I in 1..T2.lhead().len())
            nth(I, T2.lhead(), Y), % get i-th element from T2.lhead()
            log_d_vvv("eq :: eq_7 : I=" ++ I.to_string),
            log_d_vvv("eq :: eq_7 : X=" ++ X.to_string ++ ", Y=" ++ Y.to_string),
            eq(X, Y, R1),
            eq( new_lset(slice(T1.lhead(), 2), T1.lrest()),  % t_2..t_m
                new_lset(slice(T2.lhead(),1,I-1) ++ slice(T2.lhead(),I+1,T2.lhead().len()), T2.lrest()), % u_1..u_j-1,u_j+1..u_n
                R2),
            log_d_vvv("eq :: eq_7 : R1=" ++ R1.to_string ++ ", R2=" ++ R2.to_string),
            R := R ++ R1 ++ R2
        end,
        R := R.flatten()
    end.

eq(set([X|A]), set([Y|B]), R) ?=>                                  % 8a
    log_d_vv("eq :: eq_8a"),
    eq(X, Y, R1),
    eq($set(A), $set(B), R2),
    R = R1 ++ R2.
eq(set([X|A]), set([Y|B]), R) ?=>                                  % 8b
    log_d_vv("eq :: eq_8b"),
    eq(X, Y, R1),
    eq($set([X|A]), B, R2),
    R = R1 ++ R2.
eq(set([X|A]), set([Y|B]), R) ?=>                                  % 8c
    log_d_vv("eq :: eq_8c"),
    eq(X, Y, R1),
    eq(A, $set([Y|B]), R2),
    R = R1 ++ R2.
eq(set([X|A]), set([Y|B]), R) =>                                   % 8d
    log_d_vv("eq :: eq_8d"),
    eq(A, $set([Y|N]), R1),
    eq($set([X|N]), B, R2),
    R = R1 ++ R2.
eq(T1, T2, R), struct(T1), struct(T2) =>                           % 9
    log_d_vv("eq :: eq_9"),
    R = [],
    T1.name() == T2.name(),  % redundant check.
    T1.arity() == T2.arity(),
    foreach (I1 in 1..T1.arity())
        X1 := T1[I1], X2 := T2[I1],
        eq(X1, X2, RR),
        R := R ++ RR
    end.
%eq(T1, T2, R) =>  % temp
%    log_d_vv("eq :: eq_temp"),
%    R = [], T1 = T2.


% ****** inequality constraints

neq(T1, T2, _R), T1 == T2 =>                                        % 1
    log_d_vv("neq :: neq_1"),
    fail.
neq(T1, T2, R), nonvar(T1), var(T2) =>                             % 2
    log_d_vv("neq :: neq_2"),
    neq(T2, T1, R).
% 3
neq(T1, T2, R), occur_check(T1, T2) =>                             % 4 
    R = [].
neq(set([X|A]), set([Y|B]), R) ?=>                                 % 5a
    log_d_vv("neq :: neq_5a"),
    insl(N, $set([X|A]), R1),
    not insl(N, $set([Y|B]), R2),
    R = R1 ++ R2.
neq(set([X|A]), set([Y|B]), R) ?=>                                 % 5b
    log_d_vv("neq :: neq_5b"),
    not insl(N, $set([X|A]), R1),
    insl(N, $set([Y|B]), R2),
    R = R1 ++ R2.
neq(T1, T2, R), struct(T1), struct(T2), name(T1) !== name(T2) =>   % 6
    log_d_vv("neq :: neq_6"),
    R = [].
neq(T1, T2, R), struct(T1), struct(T2), name(T1) == name(T2) =>    % 7
    log_d_vv("neq :: neq_7"),
    T1.arity() == T2.arity(),
    X = [],
    println(X),
    foreach (I in 1..T1.arity())
        X1 = T1[I], X2 = T2[I],
        X := X ++ [$neq(X1, X2)]
    end,
    writeln(X),
    or(X, R).
neq(T1, T2, R) => % temp
    log_d_vv("neq :: neq_temp"),
    R = [$neq(T1, T2)].


% ****** membership constraints

insl(_T, set([]), R) =>         % 1
    log_d_vv("insl :: in_1"), 
    R = [], 
    false.
insl(T, set([U | UR]), R) =>   % 2
    log_d_vv("insl :: in_2"),
    T1 = $eq(T, U),
    T2 = $insl(T, $set([UR].flatten())),
    or(T1, T2, R).
insl(T, set(A), R) =>          % 3
    log_d_vv("insl :: in_3"), 
    A = [T|_X],  % non Ã¨ un vincolo, giusto? Non serve restituirlo, basta riscrivere A (?)
    R = [].


% ****** goal disjunction

%% or(T1, T2, R) is nondet
%
% Try satisfying a binary disjunction goal.
or(T1, _T2, R) ?=> 
    log_d_vv("or :: first"), 
    sat(T1, R).
or(_T1, T2, R) ?=> 
    log_d_vv("or :: second"),
    sat(T2, R).

%% or(T, R) is nondet
%
% Try satisfying a list of disjunction goals.
or([], []) ?=>
    % nothing to do.
    log_d_vv("or/2 :: first").
or([T|_Tr], R) ?=>
    % try satifying the first element of the list.
    log_d_vv("or/2 :: second"),
    sat(T, R).
or([_T|Tr], R) ?=>
    % try satisfyng the rest of the list.
    log_d_vv("or/2 :: third"),
    or(Tr, R).


% *********************************************************
% aux predicates 

%% occur_check(+X, +Y) is det
% The predicate is true whether the variable X is a member of vars(Y).
% X: the variable to find.
% Y: the lookup term.
occur_check(X, Y) => membchk(X, vars(Y)).

% R is the boolean result used for the function is_occur_check.
occur_check(X, Y, R) ?=> occur_check(X, Y), R = 1.
occur_check(_X, _Y, R) => R = 0.
is_occur_check(X, Y) = R => occur_check(X, Y, R).
