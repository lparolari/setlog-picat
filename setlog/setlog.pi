module setlog.

import log_h.
import functions_h.
import read_term_sl.
import temp.
import prompt.

main => setlog.

setlog => top_level.

%% top_level() is semidet  % XXX: find out what semidet really means!!
%
%  Check if Formula is false and fail.
%  Can be useful to see when a formula has failed and if backtracking is
%   properly used.
%
% Examples:
%  - [eq(X,5), neq(X,7)].
top_level ?=>
    log_d("setlog"),
    print("{log} => "),
    Term = read_term_sl([$variable_names(VarNames)]),
    Formula = Term,
    log_d_vv("setlog :: VarNames=" ++ VarNames.to_string),
    log_d_vv("setlog :: Formula=" ++ Formula.to_string),
    FormulaRes = solve(Formula),

    FormulaResNew = convert(FormulaRes, VarNames),
    println("" ++ FormulaResNew.to_string),

    if anothersol() == 1 then 
        fail
    end.

top_level =>
    println(no), nl,
    top_level.

anothersol() = A => 
    A = confirm("Another solution?").

convert(Term, VarNames) = TermRealNames =>
    log_d_v("convert/2"),

    TmpFileWriter = tmp_w(tmp1),
    TmpFileWriter.println(Term.to_string),
    TmpFileWriter.close(),

    TmpFileReader = tmp_r(tmp1),

    NewTerm := "",

    while (not at_end_of_stream(TmpFileReader))
        read_picat_token(TmpFileReader, TokenType, TokenValue),
        log_d_vv("convert/2 :: " ++ "(" ++ TokenType.to_string ++ ", " ++ TokenValue.to_string ++ ")"),
        if TokenType == var then 
            NewTerm := NewTerm ++ VarNames.get(TokenValue).to_string
        else 
            NewTerm := NewTerm ++ TokenValue.to_string
        end
    end,

    TmpFileReader.close(),

    TermRealNames = NewTerm,
    
    log_d_vv("convert/2 :: " ++ TermRealNames.to_string),
    true.
    %tmp_d(tmp1).

%% solve(+Formulas:[term]) is det
%
%  Solve formulas applying contraints rewrite rules. 
%  Solve each formula in Formulas calling sat/1 and keeping results from 
%   previous iteration unitl the contraint store remain unchanged.
solve(Formulas) = FormulaRes =>
    %FormulaRes = [],
    solvecont(Formulas, Formulas, FormulaRes).

% +Formulas, +FormulasPrev, -FormulaRes
%% solvecont(+F1:[term], +F2:[term], -F3:[term])
%
% F1: The goal to solve.
% F2: The previous solved goal, used to stop computation when nothing can be
%     solved more.
% F3: The solved goal.
%
% Solve the goal F1 iterating throught all its terms and solving them 
%  separately. Partial result is stored in F3, and if the partial result and
%  old result as identical, computation is stopped.  
solvecont(F1, F2, F3) => 
    log_d_v("solvecont/3"),
    log_d_vv("solvecont/3 :: (input) F1=" ++ F1.to_string),

    F3_tmp := [],
    foreach (F in F1)
        FRes = sat(F),
        log_d_vv("solvecont/3 :: FRes=" ++ FRes.to_string),
        has_failed(FRes),
        % assignment needed to append data.
        F3_tmp := F3_tmp ++ FRes
    end,

    F3 = F3_tmp,
    
    log_d_vv("solvecont/3 :: F1=" ++ F1.to_string),
    log_d_vv("solvecont/3 :: F2=" ++ F2.to_string),
    log_d_vv("solvecont/3 :: F3=" ++ F3.to_string),
    
    println("Before: " ++ F1.to_string),
    println("After: " ++ F3.to_string),

    if F2 == F3 then 
        println("Stop!")
    else
        solvecont(F3, F3, F3) 
    end.

%% has_failed(+Formula:formula) is det
%
%  Check if Formula is false and fail.
%  Can be useful to see when a formula has failed and if backtracking is
%   properly used. 
has_failed(Formula) =>
    log_d_v("has_failed/1"),
    log_d_vvv("has_failed/1 :: formula=" ++ Formula.to_string),
    Eq = is_eq(Formula, [ff]),
    log_d_vvv("has_failed/1 :: Eq=" ++ Eq.to_string),
    if Eq == 1 then
        println("Goal failed!"), 
        fail
    end.

%% sat(+F:formula) = Res:formula 
%
%  Solve constraints for F.
%  Might become useful in future when rules becomes more and more 
%   sophisticated.
sat(F) = Res =>
    log_d_v("sat/1"),
    Res = rule(F),
    log_d_vvv("sat/1 :: Res=" ++ Res.to_string).

%% rule(eq(+T1:term, +T2:term)) = Res:formula 
%
%  Solver rule for *eq* constraints.
rule(eq(T1, T2)) = Res =>
    log_d_v("rule/1 (eq)"),
    IsGround = is_eq(is_ground(T1), 1) /\ is_eq(is_ground(T2), 1),
    log_d_vvv("rule/1 (eq) :: IsGround=" ++ IsGround.to_string),
    if IsGround == 1 then
        if T1 == T2 then
            Res = [],
            log_d_vvv("rule/1 (eq) :: Res after if: " ++ Res.to_string)
        else 
            Res = [ff],
            log_d_vvv("rule/1 (eq) :: Res after else: " ++ Res.to_string)
        end
    else 
        T1 = T2,
        Res = [] %$eq(T1,T2)
    end.

%% rule(neq(+T1:term, +T2:term)) = Res:formula 
%
%  Solver rule for *neq* constraints.
rule(neq(T1, T2)) = Res =>
    log_d_v("rule/1 (neq)"),
    IsGround = is_eq(is_ground(T1), 1) /\ is_eq(is_ground(T2), 1),
    log_d_vvv("rule/1 (neq) :: is ground: " ++ IsGround.to_string),
    if IsGround == 1 then
        if T1 !== T2 then
            Res = [],
            log_d_vvv("rule/1 (neq) :: Res after if: " ++ Res.to_string)
        else 
            Res = [ff],
            log_d_vvv("rule/1 (neq) :: Res after else: " ++ Res.to_string)
        end
    else 
        Res = [$neq(T1,T2)]
    end.

%% rule(or(+T1:term, +T2:term)) = Res:formula 
rule(or(T1, T2)) = Res =>
    log_d_v("rule/1 (or)"),
    rule($or(T1, T2), Res).

%% rule(or(+T1:term, +T2:term), -Res:formula) is nondet
% 
%  Solver rule for *or* constraints.
%  First solve T1. If formula fails, solve T2 (using nondet).
rule(or(T1, _T2), Res) ?=> 
    log_d_v("rule/2/a (or)"),
    Res = solve([T1]).
rule(or(_T1, T2), Res) ?=>
    log_d_v("rule/2/b (or)"), 
    Res = solve([T2]).


rule(in(X, set(S)), Res) =>
    if is_ground(S) == 1 then
        member(X, S),
        Res := []
    else 
        Res := $eq(S, $set([X|_N]))
    end.