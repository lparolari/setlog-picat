module setlog.

import log_h.
import functions_h.

main => setlog.

%% setlog() is det
%
%  Check if Formula is false and fail.
%  Can be useful to see when a formula has failed and if backtracking is
%   properly used.
setlog =>
    log_d("setlog"),
    print("{log} => "),
    Terms = read_file_terms(),
    Formulas = Terms.flatten,
    log_d_vv("setlog :: " ++ Formulas.to_string),
    FormulaRes = solve(Formulas),

    println("" ++ FormulaRes.to_string).

%% solve(+Formulas:[term]) is det
%
%  Solve formulas applying contraints rewrite rules. 
%  Solve each formula in Formulas calling sat/1 and keeping results from 
%   previous iteration unitl the contraint store remain unchanged.
solve(Formulas) = FormulaRes =>
    %FormulaRes = [],
    solvecont(Formulas, Formulas, FormulaRes).

% +Formulas, +FormulasPrev, -FormulaRes
%% solvecont(+F1:[term], +F2:[term], -F3:[term])
%
% F1: The goal to solve.
% F2: The previous solved goal, used to stop computation when nothing can be
%     solved more.
% F3: The solved goal.
%
% Solve the goal F1 iterating throught all its terms and solving them 
%  separately. Partial result is stored in F3, and if the partial result and
%  old result as identical, computation is stopped.  
solvecont(F1, F2, F3) => 
    log_d_v("solvecont/3"),
    log_d_vv("solvecont/3 :: (input) F1=" ++ F1.to_string),

    F3_tmp := [],
    foreach (F in F1)
        FRes = sat(F),
        log_d_vv("solvecont/3 :: FRes=" ++ FRes.to_string),
        has_failed(FRes),
        % assignment needed to append data.
        F3_tmp := F3_tmp ++ FRes
    end,

    F3 = F3_tmp,
    
    log_d_vv("solvecont/3 :: F1=" ++ F1.to_string),
    log_d_vv("solvecont/3 :: F2=" ++ F2.to_string),
    log_d_vv("solvecont/3 :: F3=" ++ F3.to_string),
    
    println("Before: " ++ F1.to_string),
    println("After: " ++ F3.to_string),

    if F2 == F3 then 
        println("Stop!")
    else
        solvecont(F3, F3, F3) 
    end.

%% has_failed(+Formula:formula) is det
%
%  Check if Formula is false and fail.
%  Can be useful to see when a formula has failed and if backtracking is
%   properly used. 
has_failed(Formula) =>
    log_d_v("has_failed/1"),
    log_d_vvv("has_failed/1 :: formula=" ++ Formula.to_string),
    Eq = is_eq(Formula, [ff]),
    log_d_vvv("has_failed/1 :: Eq=" ++ Eq.to_string),
    if Eq == 1 then
        println("Goal failed!"), 
        fail
    end.

%% sat(+F:formula) = Res:formula 
%
%  Solve constraints for F.
%  Might become useful in future when rules becomes more and more 
%   sophisticated.
sat(F) = Res =>
    log_d_v("sat/1"),
    Res = rule(F),
    log_d_vvv("sat/1 :: Res=" ++ Res.to_string).

%% rule(eq(+T1:term, +T2:term)) = Res:formula 
%
%  Solver rule for *eq* constraints.
rule(eq(T1, T2)) = Res =>
    log_d_v("rule/1 (eq)"),
    IsGround = is_eq(is_ground(T1), 1) /\ is_eq(is_ground(T2), 1),
    log_d_vvv("rule/1 (eq) :: IsGround=" ++ IsGround.to_string),
    if IsGround == 1 then
        if T1 == T2 then
            Res = [],
            log_d_vvv("rule/1 (eq) :: Res after if: " ++ Res.to_string)
        else 
            Res = [ff],
            log_d_vvv("rule/1 (eq) :: Res after else: " ++ Res.to_string)
        end
    else 
        T1 = T2,
        Res = [] %$eq(T1,T2)
    end.

%% rule(neq(+T1:term, +T2:term)) = Res:formula 
%
%  Solver rule for *neq* constraints.
rule(neq(T1, T2)) = Res =>
    log_d_v("rule/1 (neq)"),
    IsGround = is_eq(is_ground(T1), 1) /\ is_eq(is_ground(T2), 1),
    log_d_vvv("rule/1 (neq) :: is ground: " ++ IsGround.to_string),
    if IsGround == 1 then
        if T1 !== T2 then
            Res = [],
            log_d_vvv("rule/1 (neq) :: Res after if: " ++ Res.to_string)
        else 
            Res = [ff],
            log_d_vvv("rule/1 (neq) :: Res after else: " ++ Res.to_string)
        end
    else 
        Res = [$neq(T1,T2)]
    end.

%% rule(or(+T1:term, +T2:term)) = Res:formula 
rule(or(T1, T2)) = Res =>
    log_d_v("rule/1 (or)"),
    rule($or(T1, T2), Res).

%% rule(or(+T1:term, +T2:term), -Res:formula) is nondet
% 
%  Solver rule for *or* constraints.
%  First solve T1. If formula fails, solve T2 (using nondet).
rule(or(T1, _T2), Res) ?=> 
    log_d_v("rule/2/a (or)"),
    Res = solve([T1]).
rule(or(_T1, T2), Res) ?=>
    log_d_v("rule/2/b (or)"), 
    Res = solve([T2]).

