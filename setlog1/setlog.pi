%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%                     The {log} interpreter and solver
%%
%%
%%                               developed by
%%                   L uca Parolari        Gianfranco Rossi
%%
%%                                 May 2019
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% module setlog
%
% @author Luca Parolari <luca.parolari23@gmail.com>
% @version 0.3.0

module setlog.

import prompt.
import log_h.

% picat setlog.pi
main => setlog.

% setlog entry point.
setlog => 
    setlog([$log_mode([none])]),
    top_level.
% setlog entry point with options.
setlog([$log_mode(LogMode)]) =>
    log_mode(LogMode).
% setlog entry point with debugger enabled.
setlog_d =>
    setlog([$log_mode([v, vv, vvv])]),
    top_level.

top_level ?=>
    log_d_v("setlog"),
    print("{log} => "),
    Term = read_term(),
    nl,
    log_d_vv("setlog :: Term="++Term.to_string),

    solve(Term, Res),

    nl,
    println("Result: " ++ Res.to_string),

    if anothersol() == 1 then 
        fail
    else
        nl, nl,
        top_level()
    end.
    
top_level =>
    println("no!"), nl, nl,
    top_level.

anothersol() = A => 
    nl,
    A = confirm("Another solution?").


solve(Formulas, FormulaRes) => %?=>
    log_d_v("solve/2"),
    FormulasNew := [],
    foreach (Formula in Formulas)
        log_d_vv("solve/2 :: foreach : Formula before="++Formula.to_string),
        sat(Formula, Res),
        log_d_vv("solve/2 :: foreach : Res="++Res.to_string),
        FormulasNew := FormulasNew ++ Res,
        log_d_vv("solve/2 :: foreach : FormulasNew="++FormulasNew.to_string),
    end,
    log_d_vv("solve/2 :: Formulas="++Formulas.to_string),
    log_d_vv("solve/2 :: FormulasNew="++FormulasNew.to_string),
    println(Formulas.to_string ++ "  ==>  " ++ FormulasNew.to_string),
    if FormulasNew !== Formulas then
        log_d_vv("solve/2 :: FOld not equal FNew"),
        solve(FormulasNew, FormulaRes)
    else
        log_d_vv("solve/2 :: FOld equal FNew"),
        FormulaRes = FormulasNew
    end.
%solve(_, Res) => println("fail!"), Res = "".
    

sat(F1, FR), F1 == [] => 
    log_d_vv("sat/2 :: empty"),
    FR = [].
sat(F1, FnewR) =>
    log_d_vv("sat/2 :: formula"),
    log_d_vv("sat/2 :: F1="++F1.to_string++", FnewR="++FnewR.to_string),
    rule(F1,FnewR).

% add a rule preprocessor that removes duplicates from $set([ ... ])
rule(eq(T1,T2), R) => eq(T1, T2, R).
rule(neq(T1, T2), R) => neq(T1, T2, R).
rule(or(T1, T2), R) => or(T1, T2, R).
rule(sin(T, X), R) => sin(T, X, R).


% ****** equality constraints

eq(T1, T2, R), nonvar(T1), var(T2) =>   % 2
    log_d_vv("eq :: eq_2"),
    eq(T2, T1, R).
%eq(T1, T2, R) =>               % 3
%    true. % TBD
%eq(T1, T2, R) =>               % 4
%    true. % TBD
eq(T1, T2, R) =>                % 1, 5
    log_d_vv("eq :: eq_1,5"),
    R = [], T1 = T2.
%eq(f(T1), g(T2)) =>             % 6
%    false.
%eq(F([T|T1]), F([U|U1])) =>     % 9
%    eq(T, U, R), 
%    eq($f([T1]), $f([U1]), R).

% ****** inequality constraints

neq(T1, T2, R), T1 == T2 =>     % 1
    log_d_vv("neq :: neq_1"),
    R = [], fail.
neq(T1, T2, R), nonvar(T1), var(T2) =>   % 2
    log_d_vv("neq :: neq_2"),
    neq(T2, T1, R).
%neq(T1, T2, R) =>               % 3
%    true. % TBD
neq(T1, T2 , R) =>
    log_d_vv("neq :: general"),
    R = [$neq(T1,T2)].


% ****** membership constraints

sin(T, set([]), R) =>         % 1
    log_d_vv("sin :: in_1"), 
    R = [], 
    false.
sin(T, set([U | UR]), R) =>   % 2
    log_d_vv("sin :: in_2"),
    T1 = $eq(T, U),
    T2 = $sin(T, $set(UR)),
    or(T1, T2, R).
sin(T, set(A), R) =>          % 3
    log_d_vv("sin :: in_3"), 
    R = [$set([T|X])].


% ****** goal disjunction

%% or(T1, T2, R) is nondet
%
% Try satisfying a binary disjunction goal.
or(T1, _T2, R) ?=> 
    log_d_vv("or :: first"), 
    sat(T1, R).
or(_T1, T2, R) ?=> 
    log_d_vv("or :: second"),
    sat(T2, R).

%% or(T, R) is nondet
%
% Try satisfying a list of disjunction goals.
or([], []) ?=>
    % nothing to do.
    log_d_vv("or/2 :: first").
or([T|Tr], R) ?=>
    % try satifying the first element of the list.
    log_d_vv("or/2 :: second"),
    sat(T, R).
or([T|Tr], R) ?=>
    % try satisfyng the rest of the list.
    log_d_vv("or/2 :: third"),
    or(Tr, R).


% *********************************************************
% aux predicates 


%occur_check(X,Y):-
%      Y =.. [_|R],
%      occur_check_list(X,R).
%
%occur_check_list(_X,[]):-!.
%occur_check_list(X,[A|R]):-
%      occur_check(X,A),
%      occur_check_list(X,R).